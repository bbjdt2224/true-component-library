{"version":3,"names":["CACHED_MAP","getIconMap","win","window","Hiveicons","map","Map","getUrl","i","url","getName","name","getNamedUrl","get","getAssetPath","isStr","toLowerCase","trim","invalidChars","replace","val","validateContent","svgContent","div","document","createElement","innerHTML","childNodes","length","nodeName","removeChild","svgElm","firstElementChild","setAttribute","isValid","elm","nodeType","attributes","value","indexOf","requests","getSvgContent","req","fetch","then","rsp","status","text","Promise","resolve","set","iconCss","Icon","connectedCallback","this","waitUntilVisible","el","isVisible","loadIcon","disconnectedCallback","io","disconnect","undefined","rootMargin","cb","lazy","IntersectionObserver","data","isIntersecting","observe","defaultLabel","label","render","style","color","h","Host","role","class","subtextCss","Subtext","size","weight","maxLines"],"sources":["src/components/icon/utils.ts","src/components/icon/validate.ts","src/components/icon/request.ts","src/components/icon/icon.scss?tag=true-icon&encapsulation=shadow","src/components/icon/icon.tsx","src/components/typography/subtext/subtext.scss?tag=true-subtext&encapsulation=shadow","src/components/typography/subtext/subtext.tsx"],"sourcesContent":["import { getAssetPath } from '@stencil/core';\nimport { Icon } from './icon';\n\nlet CACHED_MAP: Map<string, string>;\n\nexport const getIconMap = (): Map<string, string> => {\n    if (!CACHED_MAP) {\n        const win = window as any;\n        win.Hiveicons = win.Hiveicons || {};\n        CACHED_MAP = win.Hiveicons.map = win.Hiveicons.map || new Map();\n    }\n    return CACHED_MAP;\n};\n\nexport const addIcons = (icons: { [name: string]: string }) => {\n    const map = getIconMap();\n    Object.keys(icons).forEach(name => {\n        map.set(name, icons[name]);\n    });\n};\n\nexport const getUrl = (i: Icon) => {\n    let url = getName(i.name);\n    if (url) {\n        return getNamedUrl(url);\n    }\n\n    return null;\n};\n\nconst getNamedUrl = (name: string) => {\n    const url = getIconMap().get(name);\n    if (url) {\n        return url;\n    }\n    return getAssetPath(`icons/${name}.svg`);\n};\n\nexport const getName = (\n    name: string | undefined\n) => {\n    if (isStr(name)) {\n        name = name.toLowerCase();\n    }\n\n    if (!isStr(name) || name.trim() === '') {\n        return null;\n    }\n\n    // only allow alpha characters and dash\n    const invalidChars = name.replace(/[a-z]|-|\\d/gi, '');\n    if (invalidChars !== '') {\n        return null;\n    }\n\n    return name;\n};\n\nexport const getSrc = (src: string | undefined) => {\n    if (isStr(src)) {\n        src = src.trim();\n        if (isSrc(src)) {\n            return src;\n        }\n    }\n    return null;\n};\n\nexport const isSrc = (str: string) => {\n    return str.length > 0 && /(\\/|\\.)/.test(str);\n};\n\nexport const isStr = (val: any): val is string => typeof val === 'string';\n","import { isStr } from './utils';\n\nexport const validateContent = (\n    svgContent: string | null\n) => {\n    if (svgContent) {\n        const div = document.createElement('div');\n        div.innerHTML = svgContent;\n\n        // setup this way to ensure it works on our buddy IE\n        for (let i = div.childNodes.length - 1; i >= 0; i--) {\n            if (div.childNodes[i].nodeName.toLowerCase() !== 'svg') {\n                div.removeChild(div.childNodes[i]);\n            }\n        }\n\n        // must only have 1 root element\n        const svgElm = div.firstElementChild;\n        if (svgElm && svgElm.nodeName.toLowerCase() === 'svg') {\n            svgElm.setAttribute('class', 's-ion-icon');\n\n            // root element must be an svg\n            // lets double check we've got valid elements\n            // do not allow scripts\n            if (isValid(svgElm as any)) {\n                return div.innerHTML;\n            }\n        }\n    }\n    return '';\n};\n\n\nexport const isValid = (elm: HTMLElement) => {\n    if (elm.nodeType === 1) {\n        if (elm.nodeName.toLowerCase() === 'script') {\n            return false;\n        }\n\n        for (let i = 0; i < elm.attributes.length; i++) {\n            const val = elm.attributes[i].value;\n            if (isStr(val) && val.toLowerCase().indexOf('on') === 0) {\n                return false;\n            }\n        }\n\n        for (let i = 0; i < elm.childNodes.length; i++) {\n            if (!isValid(elm.childNodes[i] as any)) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n","import { validateContent } from './validate';\n\nconst requests = new Map<string, Promise<string>>();\n\nexport const getSvgContent = (url: string) => {\n    // see if we already have a request for this url\n    let req = requests.get(url);\n\n    if (!req) {\n        // we don't already have a request\n        req = fetch(url).then(rsp => {\n            if (rsp.status <= 299) {\n                return rsp.text();\n            }\n            return Promise.resolve(null);\n\n        }).then(svgContent => validateContent(svgContent));\n\n        // cache for the same requests\n        requests.set(url, req);\n    }\n\n    return req;\n};\n","@import './icon-mixins'; // Size variables\n\n:host {\n    --color: currentColor;\n    display: inline-block;\n\n    /* Sized by font-size */\n    width: 1em;\n    min-width: 1em;\n\n    height: 1em;\n    min-height: 1em;\n\n    contain: strict;\n    box-sizing: content-box !important;\n\n    --transition-speed: .2s;\n}\n\n:host([size=\"xxs\"]) { font-size: #{$icon-xxs} !important; }\n:host([size=\"xs\"]) { font-size: #{$icon-xs} !important; }\n:host([size=\"s\"]) { font-size: #{$icon-s} !important; }\n:host([size=\"m\"]) { font-size: #{$icon-m} !important; }\n:host([size=\"l\"]) { font-size: #{$icon-l} !important; }\n:host([size=\"xl\"]) { font-size: #{$icon-xl} !important; }\n\n.icon-inner,\nsvg {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-shrink: 0;\n\n    width: 100%;\n    min-width: 100%;\n\n    height: 100%;\n    min-height: 100%;\n}\n\nsvg {\n    transition: fill var(--transition-speed) ease-in-out;\n    fill: var(--color);\n}\n","import { Build, Component, Element, h, Host, Prop, State, Watch } from '@stencil/core';\nimport { LabelColor } from '../../interface';\nimport { IconSizes } from './icon.interface';\nimport { getSvgContent } from './request';\nimport { getName, getUrl } from './utils';\n\n@Component({\n    tag: 'true-icon',\n    assetsDirs: ['icons'],\n    styleUrl: 'icon.scss',\n    shadow: true\n})\nexport class Icon {\n    private io?: IntersectionObserver;\n\n    @Element() el!: HTMLElement;\n\n    @State() private svgContent?: string;\n    @State() private isVisible = false;\n\n    /**\n     * Specifies the label to use for accessibility. Defaults to the icon name.\n     */\n    @Prop({ mutable: true, reflect: true }) defaultLabel?: string;\n\n    /**\n     * Specifies which icon to use from the built-in set of icons.\n     */\n    @Prop({ reflect: true }) name?: string;\n\n    /**\n     * The size of the icon: xxs through xl\n     */\n    @Prop({ reflect: true }) size?: IconSizes;\n\n    @Prop() color: LabelColor;\n\n    /**\n     * If enabled, ion-icon will be loaded lazily when it's visible in the viewport.\n     * Default, `false`.\n     */\n    @Prop() lazy = false;\n\n    connectedCallback() {\n        // purposely do not return the promise here because loading\n        // the svg file should not hold up loading the app\n        // only load the svg if it's visible\n        this.waitUntilVisible(this.el, '50px', () => {\n            this.isVisible = true;\n            this.loadIcon();\n        });\n    }\n\n    disconnectedCallback() {\n        if (this.io) {\n            this.io.disconnect();\n            this.io = undefined;\n        }\n    }\n\n    private waitUntilVisible(el: HTMLElement, rootMargin: string, cb: () => void) {\n        if (Build.isBrowser && this.lazy && typeof window !== 'undefined' && (window as any).IntersectionObserver) {\n            const io = this.io = new (window as any).IntersectionObserver((data: IntersectionObserverEntry[]) => {\n                if (data[0].isIntersecting) {\n                    io.disconnect();\n                    this.io = undefined;\n                    cb();\n                }\n            }, { rootMargin });\n\n            io.observe(el);\n\n        } else {\n            // browser doesn't support IntersectionObserver\n            // so just fallback to always show it\n            cb();\n        }\n    }\n\n    @Watch('name')\n    loadIcon() {\n        if (Build.isBrowser && this.isVisible) {\n            const url = getUrl(this);\n            if (url) {\n                getSvgContent(url)\n                    .then(svgContent => this.svgContent = svgContent);\n            }\n        }\n\n        if (!this.defaultLabel) {\n            const label = getName(this.name);\n            // user did not provide a label\n            // come up with the label based on the icon name\n            if (label) {\n                this.defaultLabel = label\n                    .replace('ios-', '')\n                    .replace('md-', '')\n                    .replace(/\\-/g, ' ');\n            }\n        }\n    }\n\n    render() {\n        const style = {};\n        if (this.color) {\n            style['--color'] = `var(--color-${this.color})`;\n        }\n        return (\n            <Host role='img'\n            style={style}>{(\n                (Build.isBrowser && this.svgContent)\n                    ? <div class='icon-inner' innerHTML={this.svgContent}></div>\n                    : <div class='icon-inner'></div>\n            )}\n            </Host>\n        );\n    }\n}\n",":host {\r\n    display: block;\r\n    --color: var(--color-primary);\r\n\r\n    true-text-base {\r\n        --line-height: 20px;\r\n        --text-color: var(--color);\r\n    }\r\n}","import { Component, h, Prop } from '@stencil/core';\r\nimport { TextColor, TextWeight } from '../text-base/text-base.interface';\r\n\r\n@Component({\r\n  tag: 'true-subtext',\r\n  styleUrl: 'subtext.scss',\r\n  shadow: true,\r\n})\r\nexport class Subtext {\r\n  /**\r\n   * Passthrough prop for weight of the text\r\n   */\r\n  @Prop({ reflect: true }) weight: Extract<TextWeight, 'regular' | 'medium' | 'bold'> = 'regular';\r\n\r\n  /**\r\n   * Passthrough prop for the color of the text\r\n   */\r\n  @Prop({ reflect: true }) color: TextColor;\r\n\r\n  /**\r\n   * The maximum lines to display before truncating the text.\r\n   * Default behavior shows all lines of text with no truncation.\r\n   */\r\n  @Prop({ reflect: true }) maxLines: string;\r\n\r\n  render() {\r\n    return (\r\n      <true-text-base size=\"s\" weight={this.weight} maxLines={this.maxLines} color={this.color}>\r\n        <slot></slot>\r\n      </true-text-base>\r\n    );\r\n  }\r\n}\r\n"],"mappings":"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"}